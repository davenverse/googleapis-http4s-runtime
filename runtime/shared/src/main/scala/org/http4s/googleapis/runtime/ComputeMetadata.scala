/*
 * Copyright 2024 Yoichiro Ito
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.http4s
package googleapis.runtime
import cats.effect.Concurrent
import cats.effect.Temporal
import cats.effect.std.Env
import cats.syntax.all._
import com.comcast.ip4s.IpLiteralSyntax
import fs2.io.IOException
import io.circe.Decoder

import circe.jsonOf
import client.Client
import auth.AccessToken
import syntax.all._
import org.http4s.googleapis.runtime.Options.Standard
import org.http4s.googleapis.runtime.Options.Full
import org.http4s.googleapis.runtime.Options.FullWithLicense

trait ComputeMetadata[F[_]] {

  /** The GCP project id.
    * @see
    *   https://cloud.google.com/compute/docs/metadata/predefined-metadata-keys
    */
  def getProjectId: F[String]

  /** The zone where this VM is located. This value has the following format:
    * projects/PROJECT_NUM/zones/ZONE
    *
    * @see
    *   https://cloud.google.com/compute/docs/metadata/predefined-metadata-keys#instance-attributes-metadata
    */
  def getZone: F[String]

  /** https://cloud.google.com/compute/docs/metadata/predefined-metadata-keys
    *
    * @see
    *   The ID of the VM. This is a unique, numerical ID that is generated by Compute Engine.
    *   This is useful for identifying VMs if you don't use VM names.
    */
  def getInstanceId: F[String]

  /** The name of the VM.
    * @see
    *   https://cloud.google.com/compute/docs/metadata/predefined-metadata-keys
    */
  def getInstanceName: F[String]

  /** Refresh the access token by getting it from the GCE metadata server
    */
  def getAccessToken: F[AccessToken]

  /** Returns the email address associated with the GCE default service account.
    *
    * @see
    *   https://github.com/googleapis/google-auth-library-java/blob/ab872812d0f6e9ad7598ba4c4c503d5bff6c2a2b/oauth2_http/java/com/google/auth/oauth2/ComputeEngineCredentials.java#L512
    *   for reference
    */
  def getServiceAccount: F[String]

  /** Returns a Google ID Token from the metadata server on ComputeEngine
    * @param audience
    *   the aud: field the IdToken should include
    * @return
    *   IdToken signed by Google which includes the raw id_token
    *
    * @see
    *   https://google.aip.dev/auth/4116
    */
  def getIdToken(audience: String, options: Options = Options.Standard): F[String]
}

/** Options for id token request.
  */
sealed trait Options
object Options {
  case object Standard extends Options
  case object Full extends Options
  case object FullWithLicense extends Options
}

object ComputeMetadata {

  // `Metadata-Flavor: Google` is required to prevent SSRF since v1.
  // Without this headers, Google metadata server returns 403 response.
  private val headers = Headers("Metadata-Flavor" -> "Google")

  /** Host URI for Google metadata server. */
  private val DEFAULT_METADATA_SERVER_URL = uri"http://metadata.google.internal"

  /** Ip address for `DEFAULT_METADATA_SERVER_URL` inside Google internal DNS. */
  private[runtime] val DEFAULT_METADATA_SERVER_IP = ip"169.254.169.254"
  def apply[F[_]: Env](
      client: Client[F],
      scopes: Set[String],
  )(implicit F: Temporal[F]): F[ComputeMetadata[F]] =
    for {
      metHostOverride <- Env[F].get("GCE_METADATA_HOST")
      maybeMetServerURL <- metHostOverride
        .traverse(Uri.fromString.andThen(F.fromEither))
      metServerURL = maybeMetServerURL.getOrElse(DEFAULT_METADATA_SERVER_URL)
    } yield new ComputeMetadata[F] {

      // A base URL for compute engine metadata entries.
      val computeMetaV1: Uri = metServerURL / "computeMetadata/v1"
      def mkRequest(path: String) = Request[F](uri = computeMetaV1 / path, headers = headers)

      def get(path: String) = client.expect[String](mkRequest(path))

      val getProjectId = get("project/project-id")
      val getZone = get("instance/zone")
      val getInstanceId = get("instance/id")
      val getInstanceName = get("instance/name")

      val getServiceAccount: F[String] = {
        val serviceAccountURL =
          computeMetaV1 / "instance/service-accounts/?recursive=true"

        client
          .expectOr[ServiceAccountResponse](
            Request[F](uri = serviceAccountURL, headers = headers),
          ) {
            case Response(status @ Status.NotFound, _, _, _, _) =>
              F.pure(
                new IOException(
                  s"Error code ${status.code} trying to get service accounts from" +
                    " Compute Engine metadata. This may be because the virtual machine instance" +
                    " does not have permission scopes specified.",
                ),
              )
            case response =>
              for {
                body <- response.bodyText.compile.string
              } yield new IOException(
                s"Unexpected Error code ${response.status.code} trying to get service accounts"
                  + s" from Compute Engine metadata: $body",
              )
          }
          .map(_.default.email)
      }

      val getAccessToken: F[AccessToken] = {
        // NOTE: service account name other than `default` is deprecated.
        // See https://cloud.google.com/sdk/docs/release-notes?hl=en#18600_2018-01-24
        val tokenServerEncodedURL =
          computeMetaV1 / "instance/service-accounts/default/token"
        val tokenURLWithScopes =
          if (scopes.isEmpty) tokenServerEncodedURL
          else tokenServerEncodedURL.withQueryParam("scopes", scopes.mkString(","))
        client.expectOr(Request[F](uri = tokenURLWithScopes, headers = headers)) {
          case Response(status @ Status.NotFound, _, _, _, _) =>
            F.pure(
              new IOException(
                s"Error code ${status.code} trying to get security access token from" +
                  " Compute Engine metadata for the default service account. This may be because" +
                  " the virtual machine instance does not have permission scopes specified." +
                  " It is possible to skip checking for Compute Engine metadata by specifying the environment" +
                  " variable NO_GCE_CHECK=true",
              ),
            )
          case response =>
            for {
              body <- response.bodyText.compile.string
            } yield new IOException(
              s"Unexpected Error code ${response.status.code} trying to get security access"
                + s" token from Compute Engine metadata for the default service account: $body",
            )
        }
      }

      def getIdToken(audience: String, options: Options = Options.Standard) = {
        val identityDocumentURL =
          computeMetaV1 / "instance/service-accounts/default/identity"
        val uri = identityDocumentURL
          .withQueryParam("audience", audience)
        val uriWithOptions = options match {
          case Standard => uri
          case Full => uri.withQueryParam("format", "full")
          case FullWithLicense =>
            uri.withQueryParam("format", "full").withQueryParam("license", "TRUE")
        }

        client.expect(Request[F](uri = uriWithOptions, headers = headers))
      }
    }
}

/** service account entry in compute engine metadata.
  */
private case class ServiceAccountResponse(
    default: ServiceAccount,
)
private object ServiceAccountResponse {
  implicit def entityDec[F[_]](implicit
      F: Concurrent[F],
  ): EntityDecoder[F, ServiceAccountResponse] =
    jsonOf(
      F,
      Decoder.forProduct1[ServiceAccountResponse, ServiceAccount]("default")(
        ServiceAccountResponse(_),
      ),
    )
}
private case class ServiceAccount(
    email: String,
)
private object ServiceAccount {
  implicit def dec: Decoder[ServiceAccount] =
    Decoder.forProduct1[ServiceAccount, String]("email")(ServiceAccount(_))
  implicit def entityDec[F[_]](implicit F: Concurrent[F]): EntityDecoder[F, ServiceAccount] =
    jsonOf(F, dec)
}
